// ===== Binary Lifting for LCA + K-th Ancestor =====
// 0-based or 1-based indexing both possible; here: 1-based
// Complexity: O(n log n) preprocess, O(log n) per query

const int N = 200005;       // max nodes
const int LOG = 20;         // ceil(log2(N)) ~ 18, use 20 for safety

int up[LOG][N];             // up[k][v] = 2^k-th ancestor of v
int depth[N];
vector<int> g[N];

// ----- DFS to set depth and immediate parent -----
void dfs(int u, int p) {
    up[0][u] = p;
    for (int v : g[u]) {
        if (v == p) continue;
        depth[v] = depth[u] + 1;
        dfs(v, u);
    }
}

// ----- Preprocessing -----
void build_lca(int root = 1) {
    depth[root] = 0;
    dfs(root, 0);  // parent of root = 0 (sentinel)

    for (int k = 1; k < LOG; k++) {
        for (int v = 1; v <= n; v++) {
            int mid = up[k-1][v];
            up[k][v] = (mid ? up[k-1][mid] : 0);
        }
    }
}

// ----- K-th ancestor of u -----
int kth_ancestor(int u, int k) {
    for (int b = 0; b < LOG; b++) {
        if ((k >> b) & 1) {
            u = up[b][u];
            if (!u) break; // gone above root
        }
    }
    return u ? u : -1; // return -1 if doesn't exist
}

// ----- LCA of u, v -----
int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);

    // Lift u up to depth[v]
    int diff = depth[u] - depth[v];
    u = kth_ancestor(u, diff);

    if (u == v) return u;

    // Lift both up together
    for (int b = LOG-1; b >= 0; b--) {
        if (up[b][u] != up[b][v]) {
            u = up[b][u];
            v = up[b][v];
        }
    }
    return up[0][u]; // parent of u (or v)
}
