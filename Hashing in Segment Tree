const int MOD1 = 127657753, MOD2 = 987654319;
const int b1 = 101, b2 = 997;

ll BigMod(ll a, ll b, ll M)
{
	ll res = 1;
	a %= M;
	while (b > 0)
	{
		if (b & 1) res = (res * a) % M;
		b >>= 1;
		a = (a * a) % M;
	}
	return res;
}

int inp1, inp2;
pair<int, int> pw[N], inpw[N];
//Template from YouKnowWho and RakibJoy
void precalc()
{
	pw[0] =  {1, 1};
	for (int i = 1; i < N; i++)
	{
		pw[i].first = 1LL * pw[i - 1].first * b1 % MOD1;
		pw[i].second = 1LL * pw[i - 1].second * b2 % MOD2;
	}
	inp2 = BigMod(b2, MOD2 - 2, MOD2);
	inp1 = BigMod(b1, MOD1 - 2, MOD1);
	inpw[0] =  {1, 1};
	for (int i = 1; i < N; i++)
	{
		inpw[i].first = 1LL * inpw[i - 1].first * inp1 % MOD1;
		inpw[i].second = 1LL * inpw[i - 1].second * inp2 % MOD2;
	}

}

struct Seg_Hash {
#define lc (nd << 1)
#define rc ((nd << 1) | 1)
	vector<pii> hs;
	string s;
	int n;

	inline pii merge_hash(pii x, pii y, int z) {
		pii an;
		an.F = (x.F + (1LL * pw[z].F * y.F % MOD1)) % MOD1;
		an.S = (x.S + (1LL * pw[z].S * y.S % MOD2)) % MOD2;
		return an;
	}

	void build(int nd, int b, int e) {
		if (b == e) {
			// Hash for a single character
			hs[nd].F = (1LL * s[b] * pw[0].F % MOD1);
			hs[nd].S = (1LL * s[b] * pw[0].S % MOD2);
			return;
		}
		int mid = (b + e) >> 1;
		build(lc, b, mid);
		build(rc, mid + 1, e);
		hs[nd] = merge_hash(hs[lc], hs[rc], mid - b + 1);
	}

	pii get_hash_value(int nd, int b, int e, int l, int r) {
		if (r < b || l > e) return {0, 0};
		if (l <= b && r >= e) return hs[nd];
		int mid = (b + e) >> 1;
		pii left = get_hash_value(lc, b, mid, l, r);
		pii right = get_hash_value(rc, mid + 1, e, l, r);
		int len_left = max(0, min(mid, r) - max(b, l) + 1); // Overlap length
		return merge_hash(left, right, len_left);
	}

	void update(int nd, int b, int e, int pos, char val) {
		if (b == e) {
			hs[nd].F = (1LL * val * pw[0].F % MOD1);
			hs[nd].S = (1LL * val * pw[0].S % MOD2);
			return;
		}
		int mid = (b + e) >> 1;
		if (pos <= mid) update(lc, b, mid, pos, val);
		else update(rc, mid + 1, e, pos, val);
		hs[nd] = merge_hash(hs[lc], hs[rc], mid - b + 1);
	}
	Seg_Hash(string _ss) {
		s = "#" + _ss; // 1 - base
		n = s.size() - 1;
		hs.resize(4 * n, {0, 0});
		build(1, 1, n);
	}
};
